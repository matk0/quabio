# IMPORTANT: This file is generated by cucumber-rails - edit at your own peril.
# It is recommended to regenerate this file in the future when you upgrade to a
# newer version of cucumber-rails. Consider adding your own code to a new file
# instead of editing this one. Cucumber will automatically load all features/**/*.rb
# files.

require 'cucumber/rails'

# Enhanced test infrastructure for Miťo
require 'webmock/cucumber'
require 'database_cleaner/active_record'

# Allow real HTTP connections to localhost (for Rails server)
WebMock.disable_net_connect!(allow_localhost: true)

# Configure Capybara for different testing scenarios
Capybara.configure do |config|
  config.default_max_wait_time = 5
  config.default_selector = :css
  config.default_driver = :selenium_chrome_headless
  config.javascript_driver = :selenium_chrome_headless
  config.server_port = 9887 + ENV['TEST_ENV_NUMBER'].to_i
end

# Register additional drivers for different testing needs
Capybara.register_driver :selenium_chrome_headless do |app|
  options = Selenium::WebDriver::Chrome::Options.new
  options.add_argument('--headless')
  options.add_argument('--no-sandbox')
  options.add_argument('--disable-dev-shm-usage')
  options.add_argument('--disable-gpu')
  options.add_argument('--window-size=1400,1400')
  
  Capybara::Selenium::Driver.new(app, browser: :chrome, options: options)
end

# Mobile testing driver
Capybara.register_driver :mobile_chrome do |app|
  options = Selenium::WebDriver::Chrome::Options.new
  options.add_argument('--headless')
  options.add_argument('--no-sandbox')
  options.add_argument('--disable-dev-shm-usage')
  options.add_argument('--window-size=375,667')
  options.add_emulation(device_name: 'iPhone SE')
  
  Capybara::Selenium::Driver.new(app, browser: :chrome, options: options)
end

# Non-JavaScript driver for fallback testing
Capybara.register_driver :rack_test_no_js do |app|
  Capybara::RackTest::Driver.new(app)
end

# By default, any exception happening in your Rails application will bubble up
# to Cucumber so that your scenario will fail. This is a different from how
# your application behaves in the production environment, where an error page will
# be rendered instead.
#
# Sometimes we want to override this default behaviour and allow Rails to rescue
# exceptions and display an error page (just like when the app is running in production).
# Typical scenarios where you want to do this is when you test your error pages.
# There are two ways to allow Rails to rescue exceptions:
#
# 1) Tag your scenario (or feature) with @allow-rescue
#
# 2) Set the value below to true. Beware that doing this globally is not
# recommended as it will mask a lot of errors for you!
#
ActionController::Base.allow_rescue = false

# Enhanced database cleaner configuration
begin
  DatabaseCleaner[:active_record].strategy = :transaction
rescue NameError
  raise "You need to add database_cleaner-active_record to your Gemfile (in the :test group) if you wish to use it."
end

# Specific database strategies for different test scenarios
Before('@javascript') do
  DatabaseCleaner[:active_record].strategy = :truncation
end

Before('@api_failure') do
  DatabaseCleaner[:active_record].strategy = :truncation
  # Enable WebMock for API failure scenarios
  WebMock.enable!
end

Before('@mobile') do
  Capybara.current_driver = :mobile_chrome
end

Before('@no_javascript') do
  Capybara.current_driver = :rack_test_no_js
end

# Set up test environment before each scenario
Before do |scenario|
  # Clear any existing WebMock stubs
  WebMock.reset! if defined?(WebMock)
  
  # Set up default API response stubs for successful scenarios
  unless scenario.source_tag_names.include?('@api_failure')
    setup_default_api_stubs
  end
  
  # Clean database
  DatabaseCleaner.start
  
  # Reset any session state
  reset_session if respond_to?(:reset_session)
end

# Clean up after each scenario
After do |scenario|
  # Take screenshot if scenario failed and using JS driver
  if scenario.failed? && Capybara.current_driver != :rack_test
    screenshot_name = "failed_#{scenario.name.parameterize}.png"
    save_screenshot(screenshot_name) rescue nil
  end
  
  # Clean database
  DatabaseCleaner.clean
  
  # Reset driver to default
  Capybara.use_default_driver
  
  # Clear browser cookies and local storage
  if page.driver.respond_to?(:browser)
    page.driver.browser.manage.delete_all_cookies rescue nil
    page.execute_script('localStorage.clear();') rescue nil
    page.execute_script('sessionStorage.clear();') rescue nil
  end
  
  # Reset WebMock
  WebMock.reset! if defined?(WebMock)
end

# Configure error handling for specific scenarios
Before('@allow-rescue') do
  ActionController::Base.allow_rescue = true
end

After('@allow-rescue') do
  ActionController::Base.allow_rescue = false
end

# Performance testing setup
Before('@performance') do
  @performance_start_time = Time.current
end

After('@performance') do
  if @performance_start_time
    test_duration = Time.current - @performance_start_time
    puts "Scenario completed in #{test_duration} seconds"
  end
end

# Possible values are :truncation and :transaction
# The :transaction strategy is faster, but might give you threading problems.
# See https://github.com/cucumber/cucumber-rails/blob/master/features/choose_javascript_database_strategy.feature
Cucumber::Rails::Database.javascript_strategy = :truncation

# Helper methods for test setup
def setup_default_api_stubs
  return unless defined?(WebMock)
  
  # Default successful API responses
  stub_request(:post, /.*\/api\/chat$/)
    .to_return(
      status: 200,
      headers: { 'Content-Type' => 'application/json' },
      body: {
        response: 'Toto je testovacia odpoveď z RAG systému o slovenskom zdravotníctve.',
        sources: ['test_health_article.json']
      }.to_json
    )
  
  # Default comparison API response for admin users
  stub_request(:post, /.*\/api\/chat\/compare/)
    .to_return(
      status: 200,
      headers: { 'Content-Type' => 'application/json' },
      body: {
        variants: [
          {
            name: 'Fixed Chunking',
            response: 'Odpoveď z fixed chunking variantu.',
            sources: ['fixed_chunk_source.json'],
            metadata: { chunk_size: 512 }
          },
          {
            name: 'Semantic Chunking',
            response: 'Odpoveď zo semantic chunking variantu.',
            sources: ['semantic_chunk_source.json'],
            metadata: { similarity_threshold: 0.8 }
          }
        ]
      }.to_json
    )
  
  # Health check endpoint
  stub_request(:get, /.*\/api\/health/)
    .to_return(
      status: 200,
      headers: { 'Content-Type' => 'application/json' },
      body: {
        status: 'healthy',
        vector_stores: {
          fixed: { status: 'ready', document_count: 150 },
          semantic: { status: 'ready', document_count: 150 }
        }
      }.to_json
    )
  
  # Stats endpoint
  stub_request(:get, /.*\/api\/stats/)
    .to_return(
      status: 200,
      headers: { 'Content-Type' => 'application/json' },
      body: {
        total_documents: 150,
        variants: ['fixed', 'semantic'],
        system_info: { version: '1.0.0' }
      }.to_json
    )
end

# Custom matcher for better error messages
RSpec::Matchers.define :have_link_or_button do |text|
  match do |page|
    page.has_link?(text) || page.has_button?(text)
  end
  
  failure_message do |page|
    "Expected page to have link or button with text '#{text}', but it was not found"
  end
end

# Test data factories for quick object creation
def create_test_user(email: 'test@cucumber.test', admin: false)
  User.create!(
    email: email,
    password: 'password123',
    password_confirmation: 'password123',
    admin: admin
  )
end

def create_test_chat(user:, title: 'Test Chat')
  user.chats.create!(title: title)
end

def create_test_message(chat:, content: 'Test message', role: 'user')
  chat.messages.create!(content: content, role: role)
end

# Debugging helpers
def debug_page_content
  puts "Current URL: #{current_url}"
  puts "Page title: #{page.title}"
  puts "Page content preview: #{page.text.truncate(200)}"
end

def wait_for_ajax
  return unless page.driver.respond_to?(:evaluate_script)
  
  Timeout.timeout(Capybara.default_max_wait_time) do
    loop until page.evaluate_script('jQuery.active == 0') rescue true
  end
end

# Error logging for failed scenarios
def log_error_details(scenario)
  return unless scenario.failed?
  
  puts "\n" + "="*80
  puts "FAILED SCENARIO: #{scenario.name}"
  puts "Current URL: #{current_url}"
  puts "Page source available: #{!page.source.empty?}"
  
  if page.driver.respond_to?(:browser)
    logs = page.driver.browser.manage.logs.get(:browser) rescue []
    if logs.any?
      puts "Browser console errors:"
      logs.each { |log| puts "  #{log.level}: #{log.message}" }
    end
  end
  puts "="*80 + "\n"
end

# Hook to log error details for failed scenarios
After do |scenario|
  log_error_details(scenario) if scenario.failed?
end
